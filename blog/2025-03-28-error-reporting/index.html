<!DOCTYPE html><meta charset="utf-8"><meta content="width=device-width,initial-scale=1"name="viewport"><link href="/css/main.css"rel="stylesheet"><link href="/blog/feed.xml"rel="alternate"title="RSS Feed"type="application/atom+xml"><title>Can jank beat Clojure's error reporting?</title><meta content="Can jank beat Clojure&apos;s error reporting?"property="og:title"><meta content="Ooohh, you&apos;re in a for a treat! Learn all about the tricks of error reporting in compilers and see some incredibly fancy error output from jank."property="og:description"><meta content="https://jank-lang.org/img/logo-text-dark.png"property="og:image"><link href="/img/favicon/apple-touch-icon.png"rel="apple-touch-icon"sizes="180x180"><link href="/img/favicon/32.png"rel="icon"sizes="32x32"type="image/png"><link href="/img/favicon/16.png"rel="icon"sizes="16x16"type="image/png"><link href="/img/favicon/site.webmanifest"rel="manifest"><style>.gg-bulb{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:16px;height:16px;border:2px solid;border-bottom-color:transparent;border-radius:100px}.gg-bulb::after,.gg-bulb::before{content:"";display:block;box-sizing:border-box;position:absolute}.gg-bulb::before{border-top:0;border-bottom-left-radius:18px;border-bottom-right-radius:18px;top:10px;border-bottom:2px solid transparent;box-shadow:0 5px 0 -2px,inset 2px 0 0 0,inset -2px 0 0 0,inset 0 -4px 0 -2px;width:8px;height:8px;left:2px}.gg-bulb::after{width:12px;height:2px;border-left:3px solid;border-right:3px solid;border-radius:2px;bottom:0;left:0}.gg-check-o{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:22px;height:22px;border:2px solid;border-radius:100px}.gg-check-o::after{content:"";display:block;box-sizing:border-box;position:absolute;left:3px;top:-1px;width:6px;height:10px;border-color:currentColor;border-width:0 2px 2px 0;border-style:solid;transform-origin:bottom left;transform:rotate(45deg)}.gg-comment{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:20px;height:16px;border:2px solid;border-bottom:0;box-shadow:-6px 8px 0 -6px,6px 8px 0 -6px}.gg-comment::after,.gg-comment::before{content:"";display:block;box-sizing:border-box;position:absolute;width:8px}.gg-comment::before{border:2px solid;border-top-color:transparent;border-bottom-left-radius:20px;right:4px;bottom:-6px;height:6px}.gg-comment::after{height:2px;background:currentColor;box-shadow:0 4px 0 0;left:4px;top:4px}.gg-git-fork{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:2px;height:14px;background:currentColor}.gg-git-fork::after,.gg-git-fork::before{content:"";display:block;box-sizing:border-box;position:absolute}.gg-git-fork::before{border-right:2px solid;border-bottom:2px solid;border-bottom-right-radius:4px;bottom:4px;width:8px;height:6px;left:0}.gg-git-fork::after{width:4px;height:4px;background:currentColor;box-shadow:0 12px 0 0,6px 2px 0 0;border-radius:100%;left:-1px;top:-1px}.gg-heart,.gg-heart::after{border:2px solid;border-top-left-radius:100px;border-top-right-radius:100px;width:10px;height:8px;border-bottom:0}.gg-heart{box-sizing:border-box;position:relative;transform:translate(calc(-10px / 2 * var(--ggs,1)),calc(-6px / 2 * var(--ggs,1))) rotate(-45deg) scale(var(--ggs,1));display:block}.gg-heart::after,.gg-heart::before{content:"";display:block;box-sizing:border-box;position:absolute}.gg-heart::after{right:-9px;transform:rotate(90deg);top:5px}.gg-heart::before{width:11px;height:11px;border-left:2px solid;border-bottom:2px solid;left:-2px;top:3px}.gg-home{background:linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 0 bottom/4px 2px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat right bottom/4px 2px;box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:18px;height:14px;border:2px solid;border-top:0;border-bottom:0;border-top-right-radius:3px;border-top-left-radius:3px;border-bottom-right-radius:0;border-bottom-left-radius:0;margin-bottom:-2px}.gg-home::after,.gg-home::before{content:"";display:block;box-sizing:border-box;position:absolute}.gg-home::before{border-top:2px solid;border-left:2px solid;border-top-left-radius:4px;transform:rotate(45deg);top:-5px;border-radius:3px;width:14px;height:14px;left:0}.gg-home::after{width:8px;height:10px;border:2px solid;border-radius:100px;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom:0;left:3px;bottom:0}.gg-info{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:20px;height:20px;border:2px solid;border-radius:40px}.gg-info::after,.gg-info::before{content:"";display:block;box-sizing:border-box;position:absolute;border-radius:3px;width:2px;background:currentColor;left:7px}.gg-info::after{bottom:2px;height:8px}.gg-info::before{height:2px;top:2px}.gg-link{box-sizing:border-box;position:relative;display:block;transform:rotate(-45deg) scale(var(--ggs,1));width:8px;height:2px;background:currentColor;border-radius:4px}.gg-link::after,.gg-link::before{content:"";display:block;box-sizing:border-box;position:absolute;border-radius:3px;width:8px;height:10px;border:2px solid;top:-4px}.gg-link::before{border-right:0;border-top-left-radius:40px;border-bottom-left-radius:40px;left:-6px}.gg-link::after{border-left:0;border-top-right-radius:40px;border-bottom-right-radius:40px;right:-6px}.gg-list{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:22px;height:20px;border:2px solid;border-radius:3px}.gg-list::after,.gg-list::before{content:"";display:block;box-sizing:border-box;position:absolute;width:2px;height:2px;background:currentColor;top:3px;left:3px;box-shadow:0 4px 0,0 8px 0}.gg-list::after{border-radius:3px;width:8px;left:7px}.gg-math-minus{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:16px;height:2px;background:currentColor;border-radius:10px}.gg-slack{position:relative;box-sizing:border-box;transform:scale(var(--ggs,1));display:block;width:20px;height:20px;background:linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 7px 2px/2px 2px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 15px 7px/2px 2px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 2px 10px/2px 2px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 10px 15px/2px 2px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 10px 2px/4px 5px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 5px 12px/4px 5px}.gg-slack::after,.gg-slack::before{background:currentColor;content:"";position:absolute;box-sizing:border-box;display:block;height:4px;border-radius:22px}.gg-slack::before{width:9px;top:5px;box-shadow:10px 5px 0}.gg-slack::after{width:4px;left:5px;box-shadow:-5px 10px 0,0 10px 0,0 15px 0,5px 15px 0,5px 5px 0,5px 0 0,10px 5px 0}.gg-sync{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));border-radius:40px;border:2px solid;margin:1px;border-left-color:transparent;border-right-color:transparent;width:18px;height:18px}.gg-sync::after,.gg-sync::before{content:"";display:block;box-sizing:border-box;position:absolute;width:0;height:0;border-top:4px solid transparent;border-bottom:4px solid transparent;transform:rotate(-45deg)}.gg-sync::before{border-left:6px solid;bottom:-1px;right:-3px}.gg-sync::after{border-right:6px solid;top:-1px;left:-3px}.gg-twitter{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:20px;height:20px}.gg-twitter::after,.gg-twitter::before{content:"";display:block;position:absolute;box-sizing:border-box;left:4px}.gg-twitter::before{width:9px;height:14px;border-left:4px solid;border-bottom:4px solid;border-bottom-left-radius:6px;background:linear-gradient(to left,currentColor 12px,transparent 0) no-repeat center 2px/10px 4px;top:4px}.gg-twitter::after{width:4px;height:4px;background:currentColor;border-radius:20px;top:2px;box-shadow:7px 4px 0,7px 12px 0}</style><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),(()=>{var a="//matomo.jeaye.com/";_paq.push(["setTrackerUrl",a+"matomo.php"]),_paq.push(["setSiteId","1"]);var e=(p=document).createElement("script"),p=p.getElementsByTagName("script")[0];e.async=!0,e.src=a+"matomo.js",p.parentNode.insertBefore(e,p)})()</script><div><div><nav class="navbar is-primary"><div class="container"><div class="navbar-brand"><a class="navbar-item title has-text-white"href="/blog"style="font-family:Comfortaa"><img src="/img/logo-transparent.png"style="margin-right:15px">jank blog</a></div><div class="navbar-menu is-active"><div class="navbar-end has-text-weight-semibold"><a class="navbar-item has-text-white"href="/"><span class="icon mr-1"><i class="gg-home"></i></span><strong>Home</strong></a><a class="navbar-item has-text-white"href="/blog"><span class="icon mr-1"><i class="gg-comment"></i></span><strong>Blog</strong></a><a class="navbar-item has-text-white"href="https://github.com/sponsors/jeaye"><span class="icon mr-1"style="color:#c96198"><i class="gg-heart"></i></span><strong>Sponsor</strong></a><a class="navbar-item has-text-white"href="https://github.com/jank-lang/jank"><span class="icon mr-1"><i class="gg-git-fork"></i></span><strong>Github</strong></a><a class="navbar-item has-text-white"href="https://clojurians.slack.com/archives/C03SRH97FDK"><span class="icon mr-1"><i class="gg-slack"></i></span>Slack</a><a class="navbar-item has-text-white"href="https://twitter.com/jeayewilkerson"><span class="icon mr-1"><i class="gg-twitter"></i></span>Twitter</a></div></div></div></nav></div><section class="section"><div class="container blog-container"><span class="is-size-1">Can jank beat Clojure's error reporting?</span><div class="is-size-6 has-text-weight-light">Mar 28, 2025 ¬∑ <a class="has-text-weight-normal"href="https://github.com/jeaye">Jeaye Wilkerson</a></div><hr><div class="content"><p>Hey folks! I've spent the past quarter working on jank's error messages. I've focused on reaching parity with Clojure's error reporting and improving upon it where possible. This has been my first quarter spent working on jank <a href="/blog/2025-01-10-i-quit-my-job">full-time</a> and I've been so excited to sit at my desk every morning and get hacking. Thank you to all of my sponsors and supporters! You help make this work possible.<h2>The state of Clojure's error reporting</h2><p>Before we talk about jank, let's talk specifically about Clojure. The community wants Clojure's error reporting to improve. In the yearly State of Clojure survey, error reporting is consistently at the top of areas where improvement is desired. This applies not only to <a href="https://clojure.org/news/2024/12/02/state-of-clojure-2024">2024's results</a>. It goes <strong>all the way back</strong> to the first <a href="https://cognitect.com/blog/2016/1/28/state-of-clojure-2015-survey-results">2015 results</a>. With the work I've been doing the past quarter, I have tried to find reasons why Clojure's error reporting can't be world-class. Let's take a look at what I've built and you can be the one to decide.<h2>Starting from zero</h2><p>Three months ago, jank's error messages were abysmal. Far worse than Clojure's. The main thing I focused on, while building out jank's functionality, was that errors were raised. Not that they were helpful, just that they were raised. Let's take a more concrete look at where we started. We'll start by using this Clojure code, which has a keyword instead of a symbol for a <code>def</code>.<pre class="shiki monokai"style="background-color:#272822;color:#f8f8f2"tabindex="0"><code><span class="line"><span style="color:#fd971f">(</span><span style="color:#fb4934;font-weight:700">def</span><span style="color:#819aff"> :foo</span><span style="color:#ae81ff"> 2</span><span style="color:#fd971f">)</span></span></code></pre><p>Three months ago, we'd get this from jank.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-0.png"></figure></div><p><p>This was bad for a few reasons. Most importantly, we don't get any useful source information (file, line, column) for where the error happened. The error could be in the file we're running or in some dependent file. This wasn't helpful. I knew that, though. I just hadn't spent any time on it. Let's take a look at what Clojure gives us for the same file.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/clj-def.png"></figure></div><p><p>Ok, this is more helpful. We get the file name, line, and column. The rest of the info, on the first two lines, is largely the same as what jank provided. Clojure also provides a &quot;full report&quot; which, in this case, is 50 lines of EDN saying the same thing, but also with a JVM stack trace.<p>So, we know the minimum info we need in order to make a useful error message. We see what Clojure provides. Given the same file, jank will now report this.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-def.png"></figure></div><p><p>It's beautiful! There's a ton going on behind the scenes. Let's pick apart all of the pieces and understand how we've improved upon Clojure.<h2>Source information</h2><p>A typical compiler will lex, parse, and then semantically analyze the program. Lexing breaks the source into tokens and the compiler can keep track of the source info for those tokens. Parsing takes a stream of those tokens and turns it into language constructs, like function calls, maps, vectors, etc. The source information can be maintained, as the parse tree is being built, so that each parsed form knows where it came from. Then, when we semantically analyze those forms, we can point back to the source if we find issues.<p>In a lisp, like Clojure, this becomes a problem. After lexing, Clojure's parser will turn the tokens into Clojure data like lists, vectors, maps, etc. That's the parse tree. There is no separate data structure for it. This is incredibly powerful, since it allows the analyzer to treat any Clojure data as code, which is what enables code-as-data macro systems to work. It also introduces some limitations, though. If you want to maintain source information in the parsed objects, you either need some way of mapping back to an alternative parse tree which has that info or you need a way to tack it onto your Clojure objects. Clojure uses the latter, via metadata. Many objects in Clojure support metadata, which is just a map which anyone can cram things into. The compiler will automatically put some source info into an object's metadata. Then, during semantic analysis, it can have an idea of where the parsed objects live in the original source.<p>The key problem, though, is that <strong>many</strong> objects support metadata. Not <strong>all</strong> objects. So, the objects which don't support metadata end up with no source info. The compiler can't actually directly find out where in the source file they came from. For example, numbers like integers and doubles don't support metadata. This is likely for performance reasons, to keep them small. Keywords don't support metadata since they're interned (allocated once and deduped). So every keyword <code>:foo</code> in your source file actually maps to one object.<h3>Reparsing</h3><p>I'm going to keep focusing on this same <code>(def :foo 2)</code> example for now, since it's such a good one. When we look back at Clojure's error output, we see that it showed some file/line/column information, but it said the error happened a line 1, column 1. Arguably, the error is that <code>:foo</code> needs to be a symbol. Sure, the problem started at line 1, column 1, with the start of the <code>(def</code>, but the most helpful place to point is at <code>:foo</code>. As we discussed, though, <code>:foo</code> doesn't have any metadata, so we have no source info for it! How do we find out where <code>:foo</code> actually is?<p>There are different ways you could go about this, but the most compelling option I found was to go <strong>back to the source</strong> and reparse. In our case, <code>(def :foo 2)</code> exists in a list and lists have metadata. That means we have the source info for the list and we know that <code>:foo</code> is the second form in the list. So jank will actually go back to the file, start lexing again, at the list, and read the second form in there. With that, we'll have the full source info for <code>:foo</code> so we can properly point at it.<p>Thanks to <a href="https://ambrosebs.com/">Ambrose Bonnaire-Sergeant</a>, creator of <a href="https://typedclojure.org/">Typed Clojure</a>, who originally suggested this reparsing approach to me during a brainstorming call. It saved me from having to go down some undesirable roads.<h2>A nice UI</h2><p>Let's take a step back for a bit and talk about how I approached this quarter. At the start, I mocked up some sample errors and showed them around for feedback. Before I did that, even, I made a list of all the important parts I wanted to include. The main items for the UI were:<ul><li>Human-readable error ids (thanks to <a href="https://github.com/dustingetz">Dustin Getz</a> for the suggestion)<li>Precise source information (like we talked about above)<li>Highlighted code snippets<li>Notes identifying errors and other relevant forms</ul><p>Let's look at a more interesting example which demonstrates all of these.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-nested.png"></figure></div><p><p>Each error has an id which is the first thing you see (<code>parse/nested-shorthand-function</code>). In the future, jank will have a dedicated web page for each of these, on the jank website. The web page will expand on the explanation, provide examples, and suggest common fixes. This should be the first result in your web search for the error.<p>Next, we point exactly where the nested <code>#()</code> form starts and we show it in a highlighted snippet. We also point at the outer <code>#()</code> form which is preventing the inner <code>#()</code> form from being valid. Note, there are lines between 9 and 15 which are collapsed, since they're not relevant. We're optimizing for showing the most important bits of code for you to understand and fix the issue.<p>Let's see what Clojure does, given the same source.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/clj-nested.png"></figure></div><p><p>In our first example, <code>(def :foo 2)</code>, Clojure was unable to present precise source info. In this example, however, it does. The nested <code>#()</code> form is at line 17 and reasonably starts anywhere from column 20 to 22. However, Clojure doesn't provide a human readable error id, code snippets, or any other relevant information, such as the location of the outer <code>#()</code> form.<h2>Graceful lexing</h2><p>The highlighter for jank's code snippets is based on jank's lexer. However, we run into a problem of needing to highlight source code which we know, in some way, is incorrect. If it weren't incorrect, we wouldn't be showing an error with a code snippet. Unfortunately, the code could be so incorrect that it doesn't correctly lex. We gracefully handle this by skipping the highlighting for such tokens and resuming highlighting with the next valid token.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-lex.png"></figure></div><p><p>In Clojure, you can have <code>:c</code> or <code>::c</code>, but you may not have <code>:::c</code>. Our error message indicates there are too many <code>:</code> and our note spells out exactly what is supported. Let's see what Clojure does with the same source.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/clj-lex.png"></figure></div><p><p>This is the first time Clojure has repeated the source back to us, in any form. I think that's helpful! Clojure gets the source info somewhat right, but it actually points <strong>after</strong> the <code>:::c</code>. That's close enough to be useful, though.<h2>JAR sources</h2><p>Clojure doesn't treat JAR sources specially, when reporting errors. In fact, it'll just show the leaf name of a file and leave it up to you to figure out if that file is in a JAR or not. When half of my Clojure files are called <code>core.clj</code>, this ends up being a problem, so I wanted to tackle it in jank. Let's assume we have a nice lib we want to use, called <code>mylib</code>. We set up a small Clojure file to use it and try calling one of its functions.<pre class="shiki monokai"style="background-color:#272822;color:#f8f8f2"tabindex="0"><code><span class="line"><span style="color:#fd971f">(</span><span style="color:#fb4934;font-weight:700">ns</span><span style="color:#f8f8f2"> test</span></span>
<span class="line"><span style="color:#fd971f">  (</span><span style="color:#819aff">:require</span><span style="color:#fd971f"> [</span><span style="color:#f8f8f2">mylib</span><span style="color:#fd971f">]))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#fd971f">(</span><span style="color:#a6e22e">mylib/foo</span><span style="color:#fd971f">)</span></span></code></pre><p>Ah, but <code>mylib</code> actually has a bug.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-jar.png"></figure></div><p><p>Ignore the macro expansion bit. We're not there yet. üòÅ So <code>mylib</code> is trying to use <code>recur</code> from within a <code>try</code>, which is not supported. Here, jank should be pointing at the <code>try</code> to say where it starts. That would be more helpful and I have a <a href="https://github.com/jank-lang/jank/blob/3c568dfdee5aeb621cf7ac60f2080729dd4315f2/compiler%2Bruntime/src/cpp/jank/analyze/processor.cpp#L803">TODO in the code</a> for it. But note this: we're treating the JAR file specially, by showing its JAR path and then the file path within the JAR. Here's what Clojure shows, given the same sources (quite the mouthful of a command).<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/clj-jar.png"></figure></div><p><h2>Support jank</h2><p>I hope that this post, so far, demonstrates the level of quality I produce and my attention to detail. I hope that reading about jank gets you excited for the possibilities of Clojure, not only in terms of a native runtime and C++ interop, but also general niceties like world-class error reporting.<p>If I've hit the mark here, please consider <a href="https://github.com/sponsors/jeaye">sponsoring me</a>. I ultimately want to build a non-profit jank software foundation, hire others to help full-time, and give back to the software which makes jank possible. Before that, though, I need to prove it's viable for me alone to do this full-time. If you love what I'm building, please chip in $10/m to help make this dream possible. This year, we're going to release the first alpha for jank.<p>Thank you! Back to the post. üôÇ<h2>Macros</h2><p>There's another huge snag, when it comes to reporting errors in a lisp. Tons of the familiar constructs we use every day are actually macros which generate code for us. In Clojure, that includes <code>defn</code>, <code>fn</code>, <code>let</code>, <code>loop</code>, <code>when</code> and more. In order to be able to provide <strong>precise</strong> error messages, we need to track source information as it moves through macros. Let's take a look at what I mean.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-macro-def.png"></figure></div><p><p>Here we have a macro which has a bug in it. The <code>def</code> which it generates uses <code>:foo</code> as the name, but it has to be a symbol, not a keyword. Now, we called this macro on line 6, but jank determines that the error is actually due to the <code>:foo</code> on line 4. This is because it uses reparsing from the <code>def</code> to find <code>:foo</code>. However, it can only do that because jank keeps track of the source info on syntax quoted forms, so that the syntax quoted list for <code>def</code> can be used to find the name within. Clojure doesn't do this.<p>If we were to give this to Clojure, it would only point out where the macro was first called. Clojure doesn't point to any sources within macros.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/clj-def-2.png"></figure></div><p><p>This is where jank really starts to shine. We provide the same info as Clojure, but take it a step further because we know more about syntax quoted sources. However, jank is still working on limited info, in this example, since it doesn't have the source information for <code>:foo</code> and needs to reparse it. If we actually have the source information, we can provide even more info.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-macro-def-2.png"></figure></div><p><p>Here, we know where <code>[1 2 3]</code> comes from, but we also track <strong>where it's used</strong> in the macro. This is incredibly powerful, since it allows us to point at both of these locations. Clojure just shows the same thing as it did in the previous example, only pointing at line 6 where the macro expansion happens.<p>jank keeps track of the original form of macro expansions, so when we're analyzing some code, we can know where it came from. This is a stack, though, since one macro can expand into code which uses another macro, which expands into more code which uses other macros, and so on. We need to intelligently show only the &quot;right&quot; macro, in the source code, even though jank has access to the entire stack. For example, in the following code, we're using macros like <code>let</code>, <code>when</code>, and <code>fn</code> in both the outer source and in the syntax quoted list. jank will know that we only want to point at the expansion on line 10, though.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-macro-def-3.png"></figure></div><p><p>This is one area of the error reporting which I didn't think would be possible. To its credit, Clojure does a great job at always pointing directly at the latest macro expansion, too. It just lacks all of the nuance of being able to say what went wrong <strong>in the macro itself</strong>.<h3>Synthetic macro data</h3><p>Not all macros use syntax quoting, which means not all returned macro data will have source info. In those cases, jank will be unable to refer to where particular data is used. For example, taking our <code>my-def</code> macro from above, we can return synthetic data instead. That just means we return <code>(list 'def name val)</code>. The error which jank reports will not point at <code>name</code> within the macro, since there's no source trail to get us there.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-synthetic.png"></figure></div><p><p>To get the best error reporting possible, use syntax quoting whenever you can, in macros.<h2>A different approach to understanding errors</h2><p>This style of reporting may seem odd to you. When I showed a friend of mine, he was concerned that it's not just pointing him at one place to start his search. I think we've been trained to think like that because our tooling has been poor. What I really want is to be given a snapshot of information, connecting all of the relevant bits of code, so that I can understand the source of the problem more quickly. That's why jank shows multiple notes together, in one snippet. It's about framing a picture and highlighting the key areas. I love it.<h2>Runtime errors</h2><p>Once your program is written and properly compiling, we're not out of the error reporting business yet. jank and Clojure are still responsible for reporting uncaught exceptions. There are actually a few interesting cases here, so let's break it down.<ol><li><strong>Typical run-time exception</strong> - Some part of your code, or your dependencies, threw an exception you didn't catch. This happened as part of a REPL evaluation or AOT program execution.<li><strong>Macro expansion exception</strong> - This is arguably a run-time exception which happens at compile-time, since macros bridge the gap between those two worlds.<li><strong>Compile-time exception</strong> - If you call <code>eval</code> at run-time, to compile some code, and there are issues in that code, the compiler error is thrown. This is a compile-time error thrown at run-time.</ol><p>Let's take a look at each of these in turn, since the way we handle them is slightly different.<h3>Typical run-time exception</h3><p>When an exception is uncaught at run-time, Clojure will print a stack trace. We've all seen these, I'm sure. In C++, there's no standard way of printing a stack trace. There's a new <code>&lt;stacktrace&gt;</code> API added to C++23, but it lacks widespread adoption for now. To make matters worse, when catching an exception, there is no standard way of knowing <strong>from where</strong> it was thrown. This isn't covered by the C++23 stack trace API either. Even further, in C++, it's possible to throw <strong>anything</strong>. This makes it impossible to have a base case which can catch all exceptions while still having access to the value. Getting this behavior in the native world requires some clever hacks. Fortunately, <a href="https://rifkin.dev/">Jeremy Rifkin</a> has implemented a very cool library called <a href="https://github.com/jeremy-rifkin/cpptrace">cpptrace</a> which implements stack traces at arbitrary locations and from arbitrary exceptions.<p>Let's look at some examples, working from this Clojure source.<pre class="shiki monokai"style="background-color:#272822;color:#f8f8f2"tabindex="0"><code><span class="line"><span style="color:#fd971f">(</span><span style="color:#fb4934;font-weight:700">defn</span><span style="color:#f8f8f2"> -main </span><span style="color:#fd971f">[]</span></span>
<span class="line"><span style="color:#fd971f">  (</span><span style="color:#fb4934;font-weight:700">throw</span><span style="color:#fd971f"> (</span><span style="color:#a6e22e">Exception.</span><span style="color:#e6db74"> &quot;Failed to download file!&quot;</span><span style="color:#fd971f">)))</span></span>
<span class="line"><span style="color:#fd971f">(</span><span style="color:#a6e22e">-main</span><span style="color:#fd971f">)</span></span></code></pre><p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/clj-exception.png"></figure></div><p><p>When we run it, we see that Clojure helpfully points out line 3, which is where we call <code>(-main)</code>. It doesn't point out the actual line of the <code>throw</code>, but it gives you the last function called before the <code>throw</code>. This is because Clojure is parsing its own stack trace and pulling out the first non-Clojure frame as the source of the error. It only does this when evaluating from the REPL or running a Clojure file as a script, like we are. Clojure won't do this for AOT compiled programs. It'll just show the exception message and stack trace.<p>Now, jank isn't quite there yet. Given the same source, except we throw the string directly instead of creating a Java <code>Exception</code>, jank gives us this.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-exception.png"></figure></div><p><p>Notably, we don't have source info for the exception here. The reason that we can't right now is that frame #5 is not set, so jank inserts a note that it's not supported yet. This is because the cpptrace library doesn't yet support fetching JIT compiled frame symbols and source info. Jeremy is <a href="https://github.com/jeremy-rifkin/cpptrace/issues/226">working on it</a>, though! It shouldn't be a surprise, at this point, to say that C++ has no standard way of registering JIT compiled functions so that tools like cpptrace can access their symbols. In fact, the JIT landscape for C++ is still very green.<h3>Macro expansion exception</h3><p>So, run-time errors get a stack trace printed, in jank. Compile-time errors get fancy source info with notes. Macro expansion errors span both compile-time and run-time, though, in that macro expansion happens at compile-time, but macros run normal Clojure code in a way which is indistinguishable from run-time. To address this, jank does both forms of error reporting for macro expansion failures. It points at the macro which caused the issue, provides the error which was raised, and then also gives a stack trace.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-exception-2.png"></figure></div><p><p>Clojure gives basically the same output regardless of the exception being thrown during macro expansion or normal function evaluation, pointing at the same place (line 3).<h3>Compile-time exception</h3><p>Finally, we have the last interesting case. If we try to compile some code at run-time, and that fails, jank will try to report it as a compiler error, without the stack trace. This is because jank tries to only show the stack trace for run-time errors. Stack traces are noisy.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/jank-eval.png"></figure></div><p><p>Clojure gives no inclination to this being a special case and reports it just as it did before.<p><div class="wide-figure"><figure><img src="/img/blog/2025-03-28-error-reporting/clj-if.png"></figure></div><p><h2>Wrapping up</h2><p>That was quite the tour of Clojure's error reporting! I think we've clearly identified several ways Clojure can improved. We've also highlighted a couple of areas where jank is still lacking. I want jank to be world-class and I'll keep addressing each of these weaker areas as they're identified. When I started this quarter, I knew I'd be able to match Clojure, but I didn't think I'd be able to achieve this level of helpfulness, polish, and precision. I'm extremely pleased with how the quarter has gone.<h2>Next up</h2><p>Next quarter, I'm focusing solely on jank's seamless C++ interop. We'll be able to create stack-allocated locals of arbitrary C++ types, access their members, ensure their destructors get called, and even JIT instantiate new templates. The syntax will feel very familiar to existing Clojure users. This level of interop with C++, from a lisp, will be unprecedented. Hang tight for some more updates in the coming weeks!<h2>Would you like to help out?</h2><ol><li>Join the community on <a href="https://clojurians.slack.com/archives/C03SRH97FDK">Slack</a><li>Join the design discussions or pick up a ticket on <a href="https://github.com/jank-lang/jank">GitHub</a><li>Considering becoming a <a href="https://github.com/sponsors/jeaye">Sponsor</a> <span class="icon mr-1"style="color:#c96198"><i class="gg-heart"></i></span><li><strong>Better yet, reach out to discuss corporate sponsorship!</strong></ol></div></div></section></div><footer class="footer"><div class="container"><div class="columns has-text-centered"></div><div class="container has-text-centered"><div class="content is-small"><p>¬© 2025 Jeaye Wilkerson | All rights reserved.</div></div></div></footer><noscript><p><img src="//matomo.jeaye.com/matomo.php?idsite=1&amp;rec=1"style="border:0"alt=""></p></noscript><script>for(var coll=document.getElementsByClassName("collapsible"),i=0;i<coll.length;i++)coll[i].addEventListener("click",function(){this.classList.toggle("active");var l=this.nextElementSibling;"block"===l.style.display?l.style.display="none":l.style.display="block"})</script>