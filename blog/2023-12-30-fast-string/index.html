<!DOCTYPE html><meta charset="utf-8"><meta content="width=device-width,initial-scale=1"name="viewport"><link href="/img/favicon.svg"rel="icon"type="image/svg+xml"><link href="/css/main.css"rel="stylesheet"><link href="/blog/feed.xml"rel="alternate"title="RSS Feed"type="application/atom+xml"><title>jank's new persistent string is fast</title><meta content="jank&apos;s new persistent string is fast"property="og:title"><meta content="jank has a new C++ string class which is smaller and faster than std::string and folly::fbstring in benchmarks. How can that be?"property="og:description"><meta content="https://jank-lang.org/img/logo-dark.png"property="og:image"><style>.gg-bulb{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:16px;height:16px;border:2px solid;border-bottom-color:transparent;border-radius:100px}.gg-bulb::after,.gg-bulb::before{content:"";display:block;box-sizing:border-box;position:absolute}.gg-bulb::before{border-top:0;border-bottom-left-radius:18px;border-bottom-right-radius:18px;top:10px;border-bottom:2px solid transparent;box-shadow:0 5px 0 -2px,inset 2px 0 0 0,inset -2px 0 0 0,inset 0 -4px 0 -2px;width:8px;height:8px;left:2px}.gg-bulb::after{width:12px;height:2px;border-left:3px solid;border-right:3px solid;border-radius:2px;bottom:0;left:0}.gg-check-o{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:22px;height:22px;border:2px solid;border-radius:100px}.gg-check-o::after{content:"";display:block;box-sizing:border-box;position:absolute;left:3px;top:-1px;width:6px;height:10px;border-color:currentColor;border-width:0 2px 2px 0;border-style:solid;transform-origin:bottom left;transform:rotate(45deg)}.gg-comment{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:20px;height:16px;border:2px solid;border-bottom:0;box-shadow:-6px 8px 0 -6px,6px 8px 0 -6px}.gg-comment::after,.gg-comment::before{content:"";display:block;box-sizing:border-box;position:absolute;width:8px}.gg-comment::before{border:2px solid;border-top-color:transparent;border-bottom-left-radius:20px;right:4px;bottom:-6px;height:6px}.gg-comment::after{height:2px;background:currentColor;box-shadow:0 4px 0 0;left:4px;top:4px}.gg-git-fork{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:2px;height:14px;background:currentColor}.gg-git-fork::after,.gg-git-fork::before{content:"";display:block;box-sizing:border-box;position:absolute}.gg-git-fork::before{border-right:2px solid;border-bottom:2px solid;border-bottom-right-radius:4px;bottom:4px;width:8px;height:6px;left:0}.gg-git-fork::after{width:4px;height:4px;background:currentColor;box-shadow:0 12px 0 0,6px 2px 0 0;border-radius:100%;left:-1px;top:-1px}.gg-heart,.gg-heart::after{border:2px solid;border-top-left-radius:100px;border-top-right-radius:100px;width:10px;height:8px;border-bottom:0}.gg-heart{box-sizing:border-box;position:relative;transform:translate(calc(-10px / 2 * var(--ggs,1)),calc(-6px / 2 * var(--ggs,1))) rotate(-45deg) scale(var(--ggs,1));display:block}.gg-heart::after,.gg-heart::before{content:"";display:block;box-sizing:border-box;position:absolute}.gg-heart::after{right:-9px;transform:rotate(90deg);top:5px}.gg-heart::before{width:11px;height:11px;border-left:2px solid;border-bottom:2px solid;left:-2px;top:3px}.gg-home{background:linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 0 bottom/4px 2px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat right bottom/4px 2px;box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:18px;height:14px;border:2px solid;border-top:0;border-bottom:0;border-top-right-radius:3px;border-top-left-radius:3px;border-bottom-right-radius:0;border-bottom-left-radius:0;margin-bottom:-2px}.gg-home::after,.gg-home::before{content:"";display:block;box-sizing:border-box;position:absolute}.gg-home::before{border-top:2px solid;border-left:2px solid;border-top-left-radius:4px;transform:rotate(45deg);top:-5px;border-radius:3px;width:14px;height:14px;left:0}.gg-home::after{width:8px;height:10px;border:2px solid;border-radius:100px;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom:0;left:3px;bottom:0}.gg-info{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:20px;height:20px;border:2px solid;border-radius:40px}.gg-info::after,.gg-info::before{content:"";display:block;box-sizing:border-box;position:absolute;border-radius:3px;width:2px;background:currentColor;left:7px}.gg-info::after{bottom:2px;height:8px}.gg-info::before{height:2px;top:2px}.gg-link{box-sizing:border-box;position:relative;display:block;transform:rotate(-45deg) scale(var(--ggs,1));width:8px;height:2px;background:currentColor;border-radius:4px}.gg-link::after,.gg-link::before{content:"";display:block;box-sizing:border-box;position:absolute;border-radius:3px;width:8px;height:10px;border:2px solid;top:-4px}.gg-link::before{border-right:0;border-top-left-radius:40px;border-bottom-left-radius:40px;left:-6px}.gg-link::after{border-left:0;border-top-right-radius:40px;border-bottom-right-radius:40px;right:-6px}.gg-list{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:22px;height:20px;border:2px solid;border-radius:3px}.gg-list::after,.gg-list::before{content:"";display:block;box-sizing:border-box;position:absolute;width:2px;height:2px;background:currentColor;top:3px;left:3px;box-shadow:0 4px 0,0 8px 0}.gg-list::after{border-radius:3px;width:8px;left:7px}.gg-math-minus{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:16px;height:2px;background:currentColor;border-radius:10px}.gg-slack{position:relative;box-sizing:border-box;transform:scale(var(--ggs,1));display:block;width:20px;height:20px;background:linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 7px 2px/2px 2px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 15px 7px/2px 2px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 2px 10px/2px 2px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 10px 15px/2px 2px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 10px 2px/4px 5px,linear-gradient(to left,currentColor 5px,transparent 0) no-repeat 5px 12px/4px 5px}.gg-slack::after,.gg-slack::before{background:currentColor;content:"";position:absolute;box-sizing:border-box;display:block;height:4px;border-radius:22px}.gg-slack::before{width:9px;top:5px;box-shadow:10px 5px 0}.gg-slack::after{width:4px;left:5px;box-shadow:-5px 10px 0,0 10px 0,0 15px 0,5px 15px 0,5px 5px 0,5px 0 0,10px 5px 0}.gg-sync{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));border-radius:40px;border:2px solid;margin:1px;border-left-color:transparent;border-right-color:transparent;width:18px;height:18px}.gg-sync::after,.gg-sync::before{content:"";display:block;box-sizing:border-box;position:absolute;width:0;height:0;border-top:4px solid transparent;border-bottom:4px solid transparent;transform:rotate(-45deg)}.gg-sync::before{border-left:6px solid;bottom:-1px;right:-3px}.gg-sync::after{border-right:6px solid;top:-1px;left:-3px}.gg-twitter{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs,1));width:20px;height:20px}.gg-twitter::after,.gg-twitter::before{content:"";display:block;position:absolute;box-sizing:border-box;left:4px}.gg-twitter::before{width:9px;height:14px;border-left:4px solid;border-bottom:4px solid;border-bottom-left-radius:6px;background:linear-gradient(to left,currentColor 12px,transparent 0) no-repeat center 2px/10px 4px;top:4px}.gg-twitter::after{width:4px;height:4px;background:currentColor;border-radius:20px;top:2px;box-shadow:7px 4px 0,7px 12px 0}</style><link rel="preconnect"href="https://fonts.googleapis.com"><link rel="preconnect"href="https://fonts.gstatic.com"crossorigin><link href="https://fonts.googleapis.com/css2?family=Comfortaa"rel="stylesheet"><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){var e="//matomo.jeaye.com/",a=(_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]),document),t=a.createElement("script"),a=a.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",a.parentNode.insertBefore(t,a)}()</script><div><div><nav class="navbar is-primary"><div class="container"><div class="navbar-brand"><a class="navbar-item title has-text-black"href="/blog"style="font-family:Comfortaa">jank blog</a></div><div class="navbar-menu is-active"><div class="navbar-end has-text-weight-semibold"><a class="navbar-item has-text-black"href="/"><span class="icon mr-1"><i class="gg-home"></i></span><strong>Home</strong></a><a class="navbar-item has-text-black"href="/blog"><span class="icon mr-1"><i class="gg-comment"></i></span><strong>Blog</strong></a><a class="navbar-item has-text-black"href="https://github.com/sponsors/jeaye"><span class="icon mr-1"style="color:#c96198"><i class="gg-heart"></i></span><strong>Sponsor</strong></a><a class="navbar-item has-text-black"href="https://github.com/jank-lang/jank"><span class="icon mr-1"><i class="gg-git-fork"></i></span><strong>Github</strong></a><a class="navbar-item has-text-black"href="https://clojurians.slack.com/archives/C03SRH97FDK"><span class="icon mr-1"><i class="gg-slack"></i></span>Slack</a><a class="navbar-item has-text-black"href="https://twitter.com/jeayewilkerson"><span class="icon mr-1"><i class="gg-twitter"></i></span>Twitter</a></div></div></div></nav></div><section class="section"><div class="container blog-container"><span class="is-size-1">jank's new persistent string is fast</span><div class="is-size-6 has-text-weight-light">Dec 30, 2023 · <a class="has-text-weight-normal"href="https://github.com/jeaye">Jeaye Wilkerson</a></div><hr><div class="content"><p>One thing I've been meaning to do is build a custom string class for jank. I had some time, during the holidays, between wrapping up this quarter's work and starting on next quarter's, so I decided to see if I could beat both <code>std::string</code> and <code>folly::fbstring</code>, in terms of performance. After all, if we're gonna make a string class, it'll need to be fast. :)<p>The back story here is that jank needs to be able to get a hash from a string, and that hash should be cached along with the string. This means I can't use existing string classes, since C++ doesn't have the <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> mechanisms needed to add this behavior without completely wrapping the class.<p>Now, I could just wrap <code>std::string</code> or <code>folly::fbstring</code>, and all their member functions but I had a couple other goals in mind, too. In particular, I want jank's string to be persistent, as the rest of its data structures are. Also, since I know jank is garbage collected, and the string is persistent, I should be able to do substring operations and string copies by sharing memory, rather than doing deep copies. To summarize these goals shortly:<h2>Goals</h2><ul><li>As fast, or faster, than <code>std::string</code> and <code>folly::fbstring</code><li>Hashing, with cached value<li>Immutable (i.e. no copy on substrings, writes only done in ctors, no mutators)<li>I don't care about complete standard compliance (which allows me to cheat)</ul><p>There are three noteworthy C++ string implementations:<ul><li><code>std::string</code> from GCC's libstdc++<li><code>std::string</code> from LLVM's libc++<li><code>folly::fbstring</code> from Facebook's folly</ul><p>Each of them uses a different memory layout and encoding scheme. GCC's string is the simplest to understand, so I started with that. libc++'s string and folly's string are similar, but folly takes things a step further, so I'm going to skip over talking about the libc++ string entirely. Let's not get ahead of ourselves, though. We're starting with GCC's string.<h2>libstdc++'s string</h2><p>Each of these strings has some features in common, but they go about it differently. In libstdc++'s string, the overall layout is composed of three things:<ol><li>A pointer to the char array<li>The length of the char array<li>The allocated capacity (which may be more than the length)</ol><p>However, one commonality each of these strings have is that they employ a &quot;small string optimization&quot; (SSO). SSO is a trick which avoids dynamic allocations by storing small strings within the memory of the string class itself, up to a certain size. To accommodate this, libstdc++'s string has a fourth member, which is a char array of 16 bytes. However, a union is used so that the 16 byte char array actually shares the same memory as the third member listed above, the capacity. Depending on whether or not the string is small (based on its length), the pointer will point at the local buffer or somewhere on the &quot;heap&quot; and the capacity will either actually be the capacity or it'll be part of the memory used to store the small string <i>in-situ</i> (in place).<p>The code for this would look like:<pre class="shiki"style="background-color:#272822"><code><span class="line"><span style="color:#66d9ef;font-style:italic">struct</span><span style="color:#f8f8f2"> </span><span style="color:#a6e22e">string</span></span>
<span class="line"><span style="color:#f8f8f2">{</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#66d9ef;font-style:italic">char</span><span style="color:#f8f8f2"> </span><span style="color:#f92672">*</span><span style="color:#f8f8f2">data;</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#66d9ef;font-style:italic">size_t</span><span style="color:#f8f8f2"> length;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#66d9ef;font-style:italic">union</span></span>
<span class="line"><span style="color:#f8f8f2">  {</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#66d9ef;font-style:italic">char</span><span style="color:#f8f8f2"> sso[</span><span style="color:#ae81ff">16</span><span style="color:#f8f8f2">];</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#66d9ef;font-style:italic">size_t</span><span style="color:#f8f8f2"> capacity;</span></span>
<span class="line"><span style="color:#f8f8f2">  };</span></span>
<span class="line"><span style="color:#f8f8f2">};</span></span></code></pre><p><p>This is a straightforward approach that ends up saving <code>sizeof(size_t)</code> in memory, per string, by overlapping the capacity and the local buffer. If they weren't overlapping, a large string (not using SSO) would have 16 bytes of completely unused and wasted memory, which makes it slower to allocate and, naturally, increases the memory usage of your program.<p>On a 64 bit system, libstdc++'s string takes up 32 bytes, half of which is used for SSO, including a null-terminator. So that means up to 15 bytes of string data can fit within the string without requiring an allocation. The plus side of this is that, on a 32 bit system, the string will take up 24 bytes and you'll still have up to 15 bytes of string data to use for SSO.<p>However, I have two key gripes with this design:<ol><li>The ratio of string bytes to SSO bytes (<code>15:32 = 0.469</code>) is not great<li>The string is already quite large and I'm looking to add a cached hash to it, which will only make it larger</ol><p>How can we do better?<h2>folly's string</h2><p>folly's string, and libc++'s string, take a different approach which is significantly more complex. However, the wins are impressive. So, we start with the same three members:<ol><li>A pointer to the char array<li>The length of the char array<li>The allocated capacity (which may be more than the length)</ol><p>That's how we handle the string in the large case. However, for the small case, we use a union over <em>all three</em> of those members, spanning the entire string. It looks like this:<pre class="shiki"style="background-color:#272822"><code><span class="line"><span style="color:#66d9ef;font-style:italic">struct</span><span style="color:#f8f8f2"> </span><span style="color:#a6e22e">string</span></span>
<span class="line"><span style="color:#f8f8f2">{</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#66d9ef;font-style:italic">struct</span><span style="color:#f8f8f2"> </span><span style="color:#a6e22e">large_storage</span></span>
<span class="line"><span style="color:#f8f8f2">  {</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#66d9ef;font-style:italic">char</span><span style="color:#f8f8f2"> </span><span style="color:#f92672">*</span><span style="color:#f8f8f2">data;</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#66d9ef;font-style:italic">size_t</span><span style="color:#f8f8f2"> length;</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#66d9ef;font-style:italic">size_t</span><span style="color:#f8f8f2"> capacity;</span></span>
<span class="line"><span style="color:#f8f8f2">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#66d9ef;font-style:italic">union</span></span>
<span class="line"><span style="color:#f8f8f2">  {</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#66d9ef;font-style:italic">uint8_t</span><span style="color:#f8f8f2"> bytes[</span><span style="color:#f92672">sizeof</span><span style="color:#f8f8f2">(large_storage)];</span></span>
<span class="line"><span style="color:#f8f8f2">    large_storage large;</span></span>
<span class="line"><span style="color:#f8f8f2">  };</span></span>
<span class="line"><span style="color:#f8f8f2">};</span></span></code></pre><p>In the small case, we have all 24 bytes to work with. But how do we distinguish between the small case and the large case? We'll dedicate one bit to that, in the right-most byte of the capacity. folly actually has three cases: small, medium, and large. It dedicates another bit, in the capacity, so if the first bit is set, it's medium, and if the second bit is set, it's large. The drawback here, aside from the complexity of bit twiddling, is that we've cut our capacity down by two bits. On a 64 bit machine, that means we only can represent capacities up to 4,611,686,018,427,387,903, instead of the full 18,446,744,073,709,551,615. Oh well.<p>So folly's capacity (on a 32bit machine) would be outlined like this.<pre class="shiki"style="background-color:#272822"><code><span class="line"><span style="color:#f92672">0</span><span style="color:#ae81ff">0000000</span><span style="color:#f8f8f2"> </span><span style="color:#f92672">0</span><span style="color:#ae81ff">0000000</span><span style="color:#f8f8f2"> </span><span style="color:#f92672">0</span><span style="color:#ae81ff">0000000</span><span style="color:#f8f8f2"> </span><span style="color:#f92672">??0</span><span style="color:#ae81ff">00000</span></span>
<span class="line"><span style="color:#f8f8f2">                           </span><span style="color:#f92672">^^^-----</span></span>
<span class="line"><span style="color:#f8f8f2">                           </span><span style="color:#f92672">|||</span></span>
<span class="line"><span style="color:#f8f8f2">                           </span><span style="color:#f92672">||</span><span style="color:#88846f">/* Actual capacity data. */</span></span>
<span class="line"><span style="color:#f8f8f2">                           </span><span style="color:#f92672">|</span><span style="color:#88846f">/* Is it large? */</span></span>
<span class="line"><span style="color:#88846f">                           /* Is it medium? */</span></span></code></pre><p>For a small string, both of those flag bits are 0. This is important and it's the final piece to a puzzle: where do we store the size, for small strings? Well, we store it in the remaining 6 bits of capacity data. But we don't just store the size, oh no. We store the <em>remaining capacity</em> (max_size - size). This lovely treat allows us to use that final byte as the null terminator when the string is full, since the two flag bits will be 0 and the remaining capacity will be 0, thus the byte will be 0.<p>This means folly's string allows for 23 bytes of small string data in a 24 byte string. That's <code>23:34 = 0.958</code>, compared to the previous <code>15:32 = 0.469</code>. Our string is 24 bytes, compared to previous 32 bytes, too! A very impressive design.<h2>Empty member optimization</h2><p>There's a trick which all three of the string classes use called <a href="https://www.cantrip.org/emptyopt.html">empty member optimization</a> and I'll explain it because it's another example of how crazy C++ is. In C++, an empty struct can't have the size of 0. It generally has the size of 1. This is important for addressing, as I'll show here.<pre class="shiki"style="background-color:#272822"><code><span class="line"><span style="color:#66d9ef;font-style:italic">struct</span><span style="color:#f8f8f2"> </span><span style="color:#a6e22e">empty</span></span>
<span class="line"><span style="color:#f8f8f2">{ };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#66d9ef;font-style:italic">struct</span><span style="color:#f8f8f2"> </span><span style="color:#a6e22e">foo</span></span>
<span class="line"><span style="color:#f8f8f2">{</span></span>
<span class="line"><span style="color:#f8f8f2">  empty e;</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#66d9ef;font-style:italic">char</span><span style="color:#f8f8f2"> </span><span style="color:#f92672">*</span><span style="color:#f8f8f2">p;</span></span>
<span class="line"><span style="color:#f8f8f2">};</span></span></code></pre><p>In this example, if <code>empty</code> had a size of 0, then both <code>e</code> and <code>p</code> would have the same address within a <code>foo</code> instance. That's not the case. Actually, it's far more complicated. Since <code>empty</code> has the size of 1, so does <code>e</code>, but since a machine word is generally larger (i.e. 64 bits), the space between <code>e</code> and <code>p</code> is filled with <em>padding</em>. On my 64 bit system, <code>e</code> is 1 byte, followed by 7 bytes of padding, followed by 8 bytes for <code>p</code>. The total size of <code>foo</code> is 16 bytes, even though it holds just a single 8 byte pointer.<p>Why does this matter?<p>Containers like strings each have an allocator type, which is generally customizable. Most, but not all, allocators are stateless, empty structs, which differ only in their function behavior. The containers need an instance of the allocator in order to be able to use it and they can't make assumptions about what state is in there. But who wants to pay for all of that padding for an empty allocator? Not me. Not the C++ standard library authors.<p>Fortunately, C++ allows for base classes to be empty, without affecting the size of the derived class. So, we wrap one of our members in a class, inherit from our allocator, and we don't actually need to pay any space or runtime cost for an empty allocator. In folly's string, it looks something like this:<pre class="shiki"style="background-color:#272822"><code><span class="line"><span style="color:#66d9ef;font-style:italic">struct</span><span style="color:#f8f8f2"> </span><span style="color:#a6e22e">string</span></span>
<span class="line"><span style="color:#f8f8f2">{</span></span>
<span class="line"><span style="color:#88846f">  /* We wrap our union in a struct and inherit from</span></span>
<span class="line"><span style="color:#88846f">     our allocator. */</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#66d9ef;font-style:italic">struct</span><span style="color:#f8f8f2"> </span><span style="color:#a6e22e">storage</span><span style="color:#f8f8f2"> : allocator_type</span></span>
<span class="line"><span style="color:#f8f8f2">  {</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#66d9ef;font-style:italic">union</span></span>
<span class="line"><span style="color:#f8f8f2">    {</span></span>
<span class="line"><span style="color:#f8f8f2">      </span><span style="color:#66d9ef;font-style:italic">uint8_t</span><span style="color:#f8f8f2"> bytes[</span><span style="color:#f92672">sizeof</span><span style="color:#f8f8f2">(large_storage)];</span></span>
<span class="line"><span style="color:#f8f8f2">      large_storage large;</span></span>
<span class="line"><span style="color:#f8f8f2">    };</span></span>
<span class="line"><span style="color:#f8f8f2">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846f">  /* This will be the same size as the union alone, assuming</span></span>
<span class="line"><span style="color:#88846f">     an empty allocator. */</span></span>
<span class="line"><span style="color:#f8f8f2">  storage store;</span></span>
<span class="line"><span style="color:#f8f8f2">};</span></span></code></pre><p>I had never seen this done, until I was studying all three of these string implementations, and each one of them does it in their own way, but it all boils down to the same trick. Fascinating!<h2>jank's string</h2><p>Ok, all of this culminates to jank getting a new string. Let's get hacking. jank has no need for a distinction between small, medium, and large, like folly has. Just small and large will work. It also has no need for separating size and capacity, since it will only ever hold as much as it needs. Small strings will be stored in-situ and large strings will be GC-allocated. All strings will be immutable.<p>Now, since all strings are immutable, and all string data is GC allocated, large strings could actually share memory trivially. So, we'd have three cases:<ol><li>Small string (all data is in the string itself)<li>Owned large string (GC allocated, but able to be deallocated in the destructor)<li>Shared large string (GC allocated, no deallocation – let the GC handle it)</ol><p>We need a way of marking which large strings are owned, though. If only there was a bit, laying around, which we could use... oh wait, folly was using two bits for medium/large and we're only using one. So we can repurpose that second bit like so:<pre class="shiki"style="background-color:#272822"><code><span class="line"><span style="color:#f92672">0</span><span style="color:#ae81ff">0000000</span><span style="color:#f8f8f2"> </span><span style="color:#f92672">0</span><span style="color:#ae81ff">0000000</span><span style="color:#f8f8f2"> </span><span style="color:#f92672">0</span><span style="color:#ae81ff">0000000</span><span style="color:#f8f8f2"> </span><span style="color:#f92672">??0</span><span style="color:#ae81ff">00000</span></span>
<span class="line"><span style="color:#f8f8f2">                           </span><span style="color:#f92672">^^^-----</span></span>
<span class="line"><span style="color:#f8f8f2">                           </span><span style="color:#f92672">|||</span></span>
<span class="line"><span style="color:#f8f8f2">                           </span><span style="color:#f92672">||</span><span style="color:#88846f">/* Actual capacity data. */</span></span>
<span class="line"><span style="color:#f8f8f2">                           </span><span style="color:#f92672">|</span><span style="color:#88846f">/* Is it owned? */</span></span>
<span class="line"><span style="color:#88846f">                           /* Is it large? */</span></span></code></pre><p><p>Now this allows us to do some very nice optimizations:<ol><li>Copy constructors are practically free, for both small and large cases<li>Substring operations are practically free as well</ol><h3>Substring trickery</h3><p>Alas, there's one big caveat with this approach: shared substrings of larger strings may not be null-terminated! For example, if I have this string:<pre class="shiki"style="background-color:#272822"><code><span class="line"><span style="color:#f8f8f2">Life before death. Strength before weakness. Journey before destination.</span></span></code></pre><p>This is 72 bytes, so definitely a large string. But what if I take a substring of just the second sentence:<pre class="shiki"style="background-color:#272822"><code><span class="line"><span style="color:#f8f8f2">Strength before weakness.</span></span></code></pre><p>Since we're sharing the memory with the larger string, there is no null-terminator there. This is important, since if we use <code>c_str()</code> or <code>data()</code> on our string, the returned C string pointer won't &quot;stop&quot; until the null, which will mean our string will appear to be this:<pre class="shiki"style="background-color:#272822"><code><span class="line"><span style="color:#f8f8f2">Strength before weakness. Journey before destination.</span></span></code></pre><p>So, since I don't care about 100% standard compliance, but I still want the API to make sense, I compromised here that <code>data()</code> doesn't need to return a null-terminated string, but that <code>c_str()</code> always will. I handle this by checking if it's shared and then lazily switching to being owned by allocating and copying the data. In the vast majority of the cases, within jank's code, <code>data()</code> is sufficient, since we also have the <code>size()</code>. We don't need to go looking for nulls. However, compatibility with the C string world is important so we meet in the middle.<h2>The results</h2><p>I implemented my string from scratch, using benchmark-driven development, taking the best of each of the strings I studied along the way. The entire string is <code>constexpr</code>, which required a <a href="https://github.com/ivmai/bdwgc/pull/603">change</a> to the Boehm GC's C++ allocator. Ultimately, I'm quite pleased with the results. Between just folly's string and libstdc++'s string, one of them is generally the clear winner in each benchmark, with folly's more complex encoding (and smaller size) making it slower for some large string operations. However, with jank's string, we have the best of both worlds. It's just as small as folly's string, but it either ties or outperforms the fastest in every benchmark. On top of that, it packs another word for the cached hash! Finally, the data sharing for copy construction and substrings leave the other strings in the dust. Take a look!<p><figure><object data="/img/blog/2023-12-30-fast-string/allocations.plot.svg"type="image/svg+xml"width="50%"><img src="/img/blog/2023-12-30-fast-string/allocations.plot.svg"width="50%"></object><figcaption>jank constructs small strings the fastest and ties with std::string for large strings.</figcaption></figure><p><p><figure><object data="/img/blog/2023-12-30-fast-string/copy.plot.svg"type="image/svg+xml"width="50%"><img src="/img/blog/2023-12-30-fast-string/copy.plot.svg"width="50%"></object><figcaption>jank ties with folly for copying small strings and seriously beats both when copying large strings.</figcaption></figure><p><p><figure><object data="/img/blog/2023-12-30-fast-string/find.plot.svg"type="image/svg+xml"width="50%"><img src="/img/blog/2023-12-30-fast-string/find.plot.svg"width="50%"></object><figcaption>jank ties with std::string for large and small string searches.</figcaption></figure><p><p><figure><object data="/img/blog/2023-12-30-fast-string/substr.plot.svg"type="image/svg+xml"width="50%"><img src="/img/blog/2023-12-30-fast-string/substr.plot.svg"width="50%"></object><figcaption>jank ties with folly for small substrings and seriously beats both when creating large substrings.</figcaption></figure><p><p>The benchmark source, which uses nanobench, can be found <a href="https://gist.github.com/jeaye/306d6aefd7ed6c29fdec6eef2cafbb1f">here</a>.<h2>Is sharing large strings a big deal?</h2><p>This is easy to quantify. When compiling <code>clojure.core</code>, with jank, we end up sharing 3,112 large strings. That's 3,112 large string deep copies, and just as many allocations, which we can completely elide. In the span of a larger application, we'll be talking about millions of allocations and deep string copies elided. It's fantastic!<h2>Wrapping up</h2><p>jank now has a persistent string which is tailored for how Clojure programs work. It shares data, reduces allocations for strings all the way up to 23 bytes (which fits most keywords, I'd bet), and supports fast, memoized hashing. Going forward, I'll be exploring whether keeping that hash around is worth the 8 bytes, but I'm thinking it is and I'd rather bite the bullet for it now than have to add it later. When string building is needed, I've aliased a very capable transient string type called <code>std::string</code>, which you can get to/from a persistent string easily.<p>There's a lot more detail I could go into about how I made these improvements, to take folly's string design and make it as fast, or faster, than libstdc++'s string in every benchmark. I optimized aspects of data locality, write ordering, branch elimination, tricks to enable <code>constexpr</code> even for complex code (like <code>reinterpret_cast</code>), etc. If you're interested in even more detail in these areas, let me know!<h2>Would you like to join in?</h2><ol><li>Join the community on <a href="https://clojurians.slack.com/archives/C03SRH97FDK">Slack</a><li>Join the design discussions or pick up a ticket on <a href="https://github.com/jank-lang/jank">GitHub</a><li>Considering becoming a <a href="https://github.com/sponsors/jeaye">Sponsor</a></ol></div></div></section></div><footer class="footer"><div class="container"><div class="columns has-text-centered"><div class="column has-text-centered"><aside class="menu"><p class="menu-label">Resources<ul class="menu-list"><li><a href="https://clojurians.slack.com/archives/C03SRH97FDK">Slack</a><li><a href="https://github.com/jank-lang/jank">Github</a><li><a href="https://jank-lang.org/blog/feed.xml">RSS</a></ul></aside></div></div><div class="container has-text-centered"><div class="content is-small"><p>© 2022 Jeaye Wilkerson | All rights reserved.</div></div></div></footer><noscript><p><img src="//matomo.jeaye.com/matomo.php?idsite=1&amp;rec=1"style="border:0"alt=""></p></noscript><script>for(var coll=document.getElementsByClassName("collapsible"),i=0;i<coll.length;i++)coll[i].addEventListener("click",function(){this.classList.toggle("active");var l=this.nextElementSibling;"block"===l.style.display?l.style.display="none":l.style.display="block"})</script>